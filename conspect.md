## Таймауты HTTP Server в Go - как работают и зачем нужны

В стандартной библиотеке Go есть замечательный пакет net/http, в котором есть структура http.Server.  
Это основная структура для написания сервиса, обрабатывающего HTTP запросы.  
У http.Server довольно много интересных параметров, но здесь нам интересны таймауты:

- ReadHeaderTimeout - время, отводимое на чтение заголовков запроса  
- ReadTimeout - максимальная продолжительность чтения полного запроса, включая тело  
- WriteTimeout - максимальное время ожидания до окончания записи ответа  
- IdleTimeout - максимальное время ожидания следующего запроса, используется keep-alive  

Чтобы лучше уложить в голове, как они используются, давайте вспомним,  
как сервер работает с входящими запросами:  

1. Подключение установлено
   |--- ReadHeaderTimeout (если установлен) ---|
2. Заголовки запроса получены
   |--- ReadTimeout (если установлен) ---|
3. Тело запроса получено, начинается обработка запроса
4. Обработка завершена, сервер начинает отправлять ответ
   |--- WriteTimeout (если установлен) ---|
5. Ответ полностью отправлен клиенту
   |--- IdleTimeout (если установлен и соединение остается открытым) ---|
6. Если не было другого запроса в течение IdleTimeout, соединение закрывается
7. Если новый запрос получен до IdleTimeout, процесс начинается сначала с шага 2  

Зачем нужно столько таймаутов?

- **Борьба с Slow loris атаками:** это тип атаки, при которой злоумышленник устанавливает соединение с сервером и отправляет  
запрос нуу оооочень медленно. Это может приводить к исчерпанию ресурсов сервера и его последующему отказу.  
Установка `ReadHeaderTimeout` и `ReadTimeout` может помочь.
- **Отправка больших данных:** возможно, клиенты отправляют нам что-то очень большое, и мы не хотим чтобы это заняло  
слишком много времени. В этом случае помогает `ReadTimeout`
- **Обратная ситуация - работа с ооочень медленными клиентами:** Встречаются клиенты со слабым каналом,  
которые принимают наш ответ очень долго (например, некоторые устройства IoT или просто регионы со слабым интернет-покрытием).  
В этом случае, если не установить `WriteTimeout`, сервер может ждать бесконечно долго, пытаясь отправить ответ,  
что может привести к исчерпанию ресурсов.
- **Ограничение использования ресурсов:** При большом количестве запросов, особенно в микросервисных архитектурах,  
установка `IdleTimeout` помогает освободить ресурсы от долгоживущих соединений, которые больше не используются.  

## Таблица команд для работы с базами данных в Go

| **Команда**   | **Категория**                | **Задача**                                                                 |   **Пример** |
| ------------- | ---------------------------- | -------------------------------------------------------------------------- |  ---------- |
| `Prepare`     | Выполнение команд             | Подготовить запрос (шаблон) для повторного использования с разными данными |  `stmt, err := db.Prepare("INSERT INTO users(name, age) VALUES($1, $2)")` |
| `Exec`        | Выполнение команд             | Выполнить команду без возврата данных (например, `INSERT`, `UPDATE`, `DELETE`) |  `_, err := db.Exec("UPDATE users SET age = $1 WHERE id = $2", 30, 1)` |
| `QueryRow`    | Получение данных              | Запросить одну строку данных (например, `SELECT ... WHERE id = ...`)       |  `err := db.QueryRow("SELECT name FROM users WHERE id = $1", 1).Scan(&name)` |
| `Query`       | Получение данных              | Запросить несколько строк данных                                           | `rows, err := db.Query("SELECT name FROM users")` |
| `Scan`        | Получение данных              | Извлечь данные из результата запроса в переменные                          | `err := rows.Scan(&name, &age)` |
| `Next`        | Итерация по результатам       | Перейти к следующей строке результата запроса                              | `for rows.Next() { ... }` |
| `Close`       | Управление ресурсами          | Закрыть результат запроса (освободить ресурсы)                             | `defer rows.Close()` |  


## Отличиями между errors.Is и errors.As
| Особенность      | `errors.Is`                                      | `errors.As`                                     |
|------------------|--------------------------------------------------|-------------------------------------------------|
| **Цель**         | Проверка, является ли ошибка определенной ошибкой | Приведение ошибки к конкретному типу           |
| **Параметры**    | Две ошибки: `err` и `target`                    | Ошибка `err` и указатель на целевой тип        |
| **Возвращаемое значение** | `bool`: true, если `err` соответствует `target` | `bool`: true, если `err` можно привести к типу |
| **Использование** | Проверка на наличие ошибки в цепочке оберток    | Извлечение информации из ошибки определенного типа |







